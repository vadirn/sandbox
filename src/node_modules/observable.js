// be careful when using observable with reference types
// subscribers and .current getter will return currentValue and not its copy
export function observable(initialValue) {
  let currentValue = initialValue;
  const subscribers = [];

  const iterateSubscribers = value => {
    subscribers.slice().forEach(s => s(value));
  };

  const subscribe = fn => {
    subscribers.push(fn);
    fn(currentValue);
    return () => {
      const index = subscribers.indexOf(fn);
      if (index >= 0) {
        subscribers.splice(index, 1);
      }
    };
  };

  const set = newValue => {
    currentValue = newValue;
    iterateSubscribers(currentValue);
  };

  return {
    subscribe,
    set,
    get current() {
      return currentValue;
    },
  };
}

export function combined(...observables) {
  const value = observable();
  const set = () => value.set(observables.map(o => o.current));
  const unsubscribers = observables.map(o => o.subscribe(set));

  return {
    subscribe: value.subscribe,
    complete: () => {
      observables.forEach(o => o.complete?.());
      unsubscribers.forEach(u => u());
    },
    get current() {
      return value.current;
    },
  };
}

export function derived(o, mapper) {
  const value = observable();
  const unsubscribe = o.subscribe(newValue => value.set(mapper(newValue)));

  return {
    subscribe: value.subscribe,
    complete: () => {
      o.complete?.();
      unsubscribe();
    },
    get current() {
      return value.current;
    },
  };
}

export function setChanged(o, newValue) {
  if (o.current !== newValue) {
    o.set(newValue);
  }
}
