import { AbortError, assert } from 'core/utils/errors';
import { observable, derived } from 'core/utils/observable';
import { loop } from 'core/utils/loop';

/**
 * Set up synchronization loop, eventual and ground value observables
 * @param {*} initialGroundValue
 * @param {function} reduceEvents - function to get eventual value
 * @param {*} synchronizeEvents - async function that is going to run in a loop
 */
export function syncable(
  initialGroundValue,
  reduceEvents = () => {},
  synchronizeEvents = async () => {}
) {
  const groundValue = observable(initialGroundValue);
  const events = observable([]);
  const syncStatus = observable(Promise.resolve());

  const eventualValue = derived(events, currentEvents =>
    reduceEvents(groundValue.current, currentEvents)
  );

  const syncLoop = loop(() => synchronizeEvents(groundValue, events));

  // restart syncLoop when events array change
  events.subscribe(currentEvents => {
    if (!syncLoop.running && currentEvents.length !== 0) {
      syncStatus.set(syncLoop());
    }
  });

  // clear events in case of an error
  syncStatus.subscribe(activeTask =>
    activeTask.catch(err => {
      events.set([]);
      throw err;
    })
  );

  const enqueueEvent = (type, ...args) => {
    events.current.push([type, ...args]);
    events.set(events.current);
  };

  return {
    groundValue,
    eventualValue,
    events,
    syncStatus,
    enqueueEvent,
  };
}

export function eventsReducer(handlers, copyGroundValue = c => c) {
  return (currentGroundValue, currentEvents) => {
    let groundValueCopy = copyGroundValue(currentGroundValue);
    currentEvents.slice().forEach(([type, ...args]) => {
      groundValueCopy =
        handlers[type]?.(...args, groundValueCopy) ?? groundValueCopy;
    });
    return groundValueCopy;
  };
}

export function eventsSynchronizer(handlers, copyGroundValue = c => c) {
  return async (groundValue, events) => {
    assert(events.current.length !== 0, new AbortError());
    const [type, ...args] = events.current.slice(0, 1)[0];
    let groundValueCopy = copyGroundValue(groundValue.current);
    groundValueCopy =
      (await handlers[type]?.(...args, groundValueCopy)) ?? groundValueCopy;
    groundValue.set(groundValueCopy);
    events.current.splice(0, 1);
    events.set(events.current);
  };
}
