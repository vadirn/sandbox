/**
 * @typedef {import('observable').Observable} Observable
 * @typedef {import('observable').ReadonlyObservable} ReadonlyObservable
 */
import { AbortError, assert } from 'errors';
import { loop } from 'loop';
import { derived, observable } from 'observable';

/**
 * Set up synchronization loop, eventual and ground value observables
 * @param {*} initialGroundValue
 * @param {(object) => object} reduceEvents - function to get eventual value
 * @param {async (object) => void} synchronizeEvents - async function that is going to run in a loop
 * @returns {{groundValue: Observable, eventualValue: ReadonlyObservable, events: Observable, syncStatus: Observable, enqueueEvent: () => void }}
 */
export function syncable(
  initialGroundValue,
  reduceEvents = () => {},
  synchronizeEvents = async () => {}
) {
  const groundValue = observable(initialGroundValue);
  const events = observable([]);
  const syncStatus = observable(Promise.resolve());

  const eventualValue = derived(events, currentEvents =>
    reduceEvents(groundValue.current, currentEvents)
  );

  const syncLoop = loop(() => synchronizeEvents(groundValue, events));

  // restart syncLoop when events array change
  events.subscribe(currentEvents => {
    if (!syncLoop.running && currentEvents.length !== 0) {
      syncStatus.set(syncLoop());
    }
  });

  // clear events in case of an error
  syncStatus.subscribe(activeTask =>
    activeTask.catch(err => {
      events.set([]);
      throw err;
    })
  );

  const enqueueEvent = (type, ...args) => {
    events.current.push([type, ...args]);
    events.set(events.current);
  };

  return {
    groundValue,
    eventualValue,
    events,
    syncStatus,
    enqueueEvent,
  };
}

/**
 * Returns reduceEvents function that iterates over events and calls corresponding handlers
 * @param {Object.<string,<T>(...args, o: T) => T} handlers
 * @param {<T>(o: T) => T} copyGroundValue
 * @returns {(currentGroundValue: any, currentEvents: []) => any}
 */
export function eventsReducer(handlers, copyGroundValue = c => c) {
  return (currentGroundValue, currentEvents = []) => {
    let groundValueCopy = copyGroundValue(currentGroundValue);
    currentEvents.slice().forEach(([type, ...args]) => {
      groundValueCopy =
        handlers[type]?.(...args, groundValueCopy) ?? groundValueCopy;
    });
    return groundValueCopy;
  };
}

/**
 * Returns synchronizeEvents function that is going to be used as loop task
 * It supposed to take first event from events observable, apply corresponding event synchronizer
 * and update groundValue
 * @param {Object.<string,<T>(...args, o: T) => Promise<T>} handlers
 * @param {<T>(o: T) => T} copyGroundValue
 * @returns {(groundValue: Observable, events: Observable) => void}
 */
export function eventsSynchronizer(handlers, copyGroundValue = c => c) {
  return async (groundValue, events) => {
    assert(events.current.length !== 0, new AbortError());
    const [type, ...args] = events.current.slice(0, 1)[0];
    let groundValueCopy = copyGroundValue(groundValue.current);
    groundValueCopy =
      (await handlers[type]?.(...args, groundValueCopy)) ?? groundValueCopy;
    groundValue.set(groundValueCopy);
    events.current.splice(0, 1);
    events.set(events.current);
  };
}
